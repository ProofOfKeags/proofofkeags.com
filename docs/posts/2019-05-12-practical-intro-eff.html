<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#0d1117">
    <title>Proof of Keags - A Practical Introduction to Freer Monads (Eff)</title>
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/syntax.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>

<body>
    <header>
        <div class="logo">
            <a href="../"><span class="proof">Proof of </span><span class="keags">Keags</span></a>
        </div>
        <nav>
            <a href="../">Posts</a>
            <a href="../about.html">About</a>
        </nav>
    </header>

    <main role="main">
        <h1>A Practical Introduction to Freer Monads (Eff)</h1>
        <article>
    <section class="header">
        Posted on May 12, 2019
        
    </section>
    <section>
        <h1 id="background">Background</h1>
<p>For the remainder of this post I’m going to assume that you roughly understand what a monad is, or
can at least understand how you would use one in a codebase that has an actual <code>main</code> method. If
not, fear not, there are a number of wonderful resources out there to teach you this, however,
unless you have that context, the rest of this post will seem useless, complicated, or both.</p>
<h1 id="motivation">Motivation</h1>
<p>I could sit here and talk about the theoretical underpinnings that make Free/r monads interesting,
but there are far more qualified people than I to talk about such things. And while they are
certainly interesting in their own right, I want to take a step back, de-emphasize the theory,
and talk about something more concrete. And while you may have never exactly encountered the scenarios
I’m about to lay out, the essence of the frustration should seem eerily familiar.</p>
<h2 id="requirements-thrash">Requirements Thrash</h2>
<p>Have you ever gotten the requirements of a project, coded it, delivered it to the stakeholder(s),
and had them accept it without a fuss the first time around? Yeah, me neither. They always want to
tweak something between that v0 you hand them before arriving at whatever becomes the stable solution
for the time being</p>
<p>Now, of course, this is fine. We want to satisfy our customers and write software that actually does what people
want it to do, but when designing this stuff, there are certain decisions you can make that make your own life
difficult if you try to change it later.</p>
<p>In most cases, when people ask you to make something, there’s a very small set of its
implementation that they care about, and that’s usually the original API that they actually
specify. Technical debates about whether you should store the data in Postgres or on the
Filesystem, or debates about whether caching is done in memory or in Redis, are things <em>you</em> get
to decide. <em>Your PM’s don’t give a shit.</em></p>
<p>So given that you’re building software for them in the first place, why would you spend any time on
the implementation details before getting the high level semantics down right?</p>
<p>Of course, that stuff still has to get done before you can actually ship the code, but a demo is
worth a thousand requirements meetings. People realistically don’t know what they want until they
see it, so can we somehow show them a version of what the system will look like before we get to
all the grimy engineering details of making it fault tolerant, performant, etc.?</p>
<p>hmm…</p>
<p>Before we answer that, let’s take a look at another situation.</p>
<h2 id="testing">Testing</h2>
<p>Testing is an interesting subject to talk about in Haskell because with such a sophisticated type
system we often find that when our software compiles it will “just work”. Now this isn’t technically
true because any monomorphic function <code>Foo -&gt; Bar -&gt; Baz</code> can have many different implementations
that satisfy that type signature, and almost certainly, at least one of them is wrong.</p>
<p>So while there are entire categories of tests we don’t have to write that people writing Ruby or JS
have to, the number of tests we have to write is still nonzero. Now, for pure functions we have some
pretty world-class tooling such as <code>quickcheck</code> and <code>hedgehog</code> which I’ve been favoring more recently,
but these things are primarily focused on testing <em>data transformations</em>.</p>
<p>However, sometimes we want to be able to write a test that ensures that <em>actions</em> produce other
actions that may not have a representation in the return type of your function. After all, how
would you go about testing whether a function <code>Foo -&gt; IO Bar</code> worked correctly? If it was supposed
to log the value of type <code>Foo</code> before grabbing the right <code>Bar</code> out of the database and returning
it, how do we make sure that log event happened?</p>
<p>It’d be nice if we could plug and play logging implementations depending on whether we were in a
test environment or the real application. But to do that we need to be able to parameterize part of
that function. The trouble is that we <em>know</em> this function needs to take a <code>Foo</code> as an argument and
yield a <code>Bar</code> as a result. So what else is there to parameterize? Can we parameterize the monad
it’s running in to be <code>Foo -&gt; m Bar</code> and then depending on the environment instantiate <code>m</code> with
either <code>IO</code> or some test monad?</p>
<p>This is roughly how the strategy of mocking things works in OOP. But we can’t let them have nicer
things than us. Is there a way we can accomplish all the same things?</p>
<p>Let’s visit one final frustration before we get to the answer.</p>
<h2 id="prove-you-cant-launch-nukes">Prove you can’t <em>Launch Nukes™</em></h2>
<p>If you spend even a little bit of time in Haskell you’ll start to lean pretty heavily on type
signatures to get an idea of what a particular piece of code is doing. <code>Asset -&gt; Price</code> probably
gives you the price of that asset, which is loads better than a comparable signature
<code>String -&gt; Double</code>. Not only because it constrains the input and output types, but also makes a
good faith effort to describe what the function is doing in a very “TL;DR” manner.</p>
<p>So what is the least descriptive type signature ever?</p>
<p>Well, given that Haskell is a general purpose programming language, and than Turing Completeness
makes it such that anything that is computable should be expressible, it stands to reason that the
type signature of our <code>main</code> method is about the most useless type signature ever, since
<em>any program at all</em> can satisfy it. So what is that type signature?</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">IO</span> ()</span></code></pre></div>
<p>Any program at all can inhabit that type. This means without scrutinizing its contents we have no
idea what it does. And while <code>()</code> is a somewhat worthless return type since it only has one
inhabitant, it’s not the scariest part of this type signature. The structurally similar
<code>Identity ()</code> is a lot clearer about what it can, or more importantly <em>can’t</em>, do.</p>
<p>So why is <code>IO</code> so scary? Because it’s more or less like giving root to someone. Once given control,
it can do whatever it wants before giving control back to the caller.</p>
<p>Nevertheless, if we want to write useful programs we need to be able to do things that require
<code>IO</code>. But what we’d want to do is constrain the <em>types</em> of <code>IO</code> it can do, and make it clear in
the type signature that those are all it requires.</p>
<p>So we want some system of specifying which types of <code>IO</code>, henceforth referred to as <em>effects</em>, in
such a way that if we needed to add more effects to that function we could easily do it, but still
be forced to say that is what we are doing.</p>
<p>Enter Eff.</p>
<h1 id="what-is-eff">What is Eff?</h1>
<p>Eff is a structure with some beautiful theoretical underpinnings that allows us to deal with the
above phenomena in a tractable and scalable way. It’s main value proposition is bisecting your
effectful code into a “what” and a “how”, along with a method of choosing the “how” at a different
call site than the what. There are numerous implementations of this idea, and the one that we’ll be
referencing throughout the rest of this post is <a href="https://hackage.haskell.org/package/freer-simple">freer-simple</a>.</p>
<p>Your business logic cares about the “what”, but your execution environment is what cares about the
“how”.</p>
<h2 id="minimum-viable-eff-effect">Minimum Viable Eff effect</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Console</span> a <span class="kw">where</span> <span class="co">-- GADT that defines the types of operations in this API</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GetLine</span><span class="ot"> ::</span> <span class="dt">Console</span> <span class="dt">String</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">PutLine</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Console</span> ()</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>makeEffect '<span class="dt">'Console</span> <span class="co">-- TH code that generates the functions you'll use in business logic</span></span></code></pre></div>
<p>So what’s going on here? We have a datatype that describes some <code>Console</code> effect that has two
operations: <code>GetLine</code> which is some effectful way of getting a <code>String</code>, and <code>PutLine</code> which takes
a <code>String</code> and does something with it and gives you back <code>()</code></p>
<p>But the magic is not in the datatype it’s in the following function definitions that are generated
automatically by the Template Haskell <code>makeEffect</code> declaration:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r <span class="dt">String</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span> <span class="ot">=</span> send <span class="dt">GetLine</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">putLine ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>putLine <span class="ot">=</span> send <span class="op">.</span> <span class="dt">PutLine</span></span></code></pre></div>
<p>What is happening here is that <code>r</code> is a <em>type-level list</em> of effects, and the <code>Member</code> constraint
is saying that <code>Console</code> must appear in that list somewhere. Finally, <code>send</code> is merely allowing us
to use these effects together with each other in a “mix and match” fashion, without having to worry
about the machinery that keeps all of this type-safe.</p>
<p>What this does is it takes the constructors for that datatype and “injects” them into the <code>Eff r</code>
monad that is completely polymorphic in r with a constraint that the Console effect is in there
somewhere.</p>
<p>Keep in mind, we haven’t said shit about how this thing is supposed to get or put lines
anywhere. We’ve just said, “hey, we want to do get and put to the console, and we’ll worry about
how to do it some other time”. So let’s consider the following program</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greetBot ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>greetBot <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    putLine <span class="st">&quot;What is your name?&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    putLine <span class="op">$</span> <span class="st">&quot;Hello, &quot;</span> <span class="op">&lt;&gt;</span> name <span class="op">&lt;&gt;</span> <span class="st">&quot;!\n&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    greetBot</span></code></pre></div>
<p>Neat. This program, from a structural standpoint looks like how we would code a bot that repeatedly
asks for your name and then greets you. We aren’t bogged down with the details about how to get
that string or send out the greeting. The code only specifies the high level design of the program.
The skeptical reader might say, well we can do that without all this Eff machinery by just pulling
out <code>getLine :: IO String</code> and <code>putLine :: String -&gt; IO ()</code> to their own function. And not only
that, but <code>base</code> already does this for us. So what have we really accomplished?</p>
<p>The answer is that not only have we packed that logic elsewhere, but we haven’t even committed to
a particular implementation yet! There are no typed holes, no <code>undefined</code>s and we still can have a
program that typechecks without having committed to these details.</p>
<p>That said, this program is still incomplete and won’t yet run, precisely because we haven’t
actually told it how to handle these gets and puts.</p>
<p>So what are we going to do in the regular program case? The aforementioned functions in base will
do just fine I think:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">consoleToIO ::</span> <span class="dt">Console</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>consoleToIO action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GetLine</span> <span class="ot">-&gt;</span> Prelude.getLine</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">PutLine</span> s <span class="ot">-&gt;</span> Prelude.putStrLn s</span></code></pre></div>
<p>This is all great, but <code>greetBot</code> isn’t actually a program of type <code>Console a</code>. Instead, it is one
that that has the type <code>Eff r a</code> where the only requirement on <code>r</code> is that it is a list that contains
<code>Console</code> in it somewhere. The minimum concretion of <code>greetBot</code> could have type <code>Eff '[Console] ()</code>, but
the point here is that it is not <em>limited</em> to that, and can be combined at will with other effects, that,
in conjunction, build up a much larger list.</p>
<p>Once this list is built, though, we need a way to independently interpret these effects. We also need to
do this in such a way that we can define the handler with no knowledge of anything besides the source and
target effects. We want this so that our effects can remain isolated from one another but can be composed
together to interpret more complicated programs.</p>
<p>This is where the value of effect libraries such as <code>freer-simple</code> start to shine.</p>
<p><code>freer-simple</code> gives us some functions to be able to take the above action mapping and use it in the
context of the <code>Eff</code> machinery.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">translate ::</span> (<span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> (f '<span class="op">:</span> r) b <span class="ot">-&gt;</span> <span class="dt">Eff</span> (g '<span class="op">:</span> r) b</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>translate <span class="ot">=</span> _</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runM ::</span> <span class="dt">Eff</span> '[m] a <span class="ot">-&gt;</span> m a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>runM <span class="ot">=</span> _</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- to close the gap</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">interpretConsoleInIO ::</span> <span class="dt">Eff</span> '[<span class="dt">Console</span>] a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>interpretConsoleInIO <span class="ot">=</span> runM <span class="op">.</span> translate consoleToIO</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> () <span class="co">-- this translation to IO happens at the edge of our program</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> interpretConsoleInIO greetBot</span></code></pre></div>
<p>Great! But how do we test it? I promised testing capabilities, I should deliver on it. To really do
that we need to tweak the original program just a bit so we can just test a single iteration of it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greetBot ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>greetBot <span class="ot">=</span> fix greetBot'</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">greetBot' ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r () <span class="ot">-&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>greetBot' continue <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    putLine <span class="st">&quot;What is your name?&quot;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    putLine <span class="op">$</span> <span class="st">&quot;Hello, &quot;</span> <span class="op">&lt;&gt;</span> name <span class="op">&lt;&gt;</span> <span class="st">&quot;!\n&quot;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    continue</span></code></pre></div>
<p>We have to do this because if we try to test a program that loops forever the test will never
terminate itself. So we’ll actually be testing greetBot’ here.</p>
<p>What is a natural way we might want to test this? Well, the main invariant here is that the thing
emitted over the put should at least contain the name obtained via the get. Let’s write out a
property test for this.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- hedgehog property test</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_nameMatchesGreeting ::</span> <span class="dt">Property</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>prop_nameMatchesGreeting <span class="ot">=</span> property <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> forAll nameGenerator</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    _ <span class="co">-- uhhh, what goes here?</span></span></code></pre></div>
<p>So we’ve run into our first issue, we want to be able to supply a name that was given to us from
the test environment to our program directly. So we want <code>greetBot'</code> to <em>read</em> for its <code>getLine</code>
call and <em>write</em> for its <code>putLine</code> call. Can we interpret our Console action into more than one
effect? Turns out yes.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- freer simple provides some out of the box reader and writer effects that behave the same way</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- that their identically named monads in `base` behave</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">consoleToReaderAndWriter ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">String</span>) r</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                            , <span class="dt">Member</span> (<span class="dt">Writer</span> [<span class="dt">String</span>]) r</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                            ) <span class="ot">=&gt;</span> <span class="dt">Console</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>consoleToReaderAndWriter action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GetLine</span> <span class="ot">-&gt;</span> ask</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">PutLine</span> s <span class="ot">-&gt;</span> tell s</span></code></pre></div>
<p>And with the appropriate functions from <code>freer-simple</code> we can interpet this down to a pure value!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- used to get from Console to Reader AND Writer</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">reinterpret2 ::</span> (<span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (g '<span class="op">:</span> h '<span class="op">:</span> r) a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> (f '<span class="op">:</span> r) b <span class="ot">-&gt;</span> <span class="dt">Eff</span> (g '<span class="op">:</span> h '<span class="op">:</span> r) b</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>reinterpret2 <span class="ot">=</span> _</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- used to discharge reader</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">runReader ::</span> env <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">Reader</span> env '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>runReader <span class="ot">=</span> _</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- used to discharge writer</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="ot">runWriter ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">Writer</span> w '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r (a, w)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>runWriter <span class="ot">=</span> _</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- used to discharge Eff machinery around a pure value</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="ot">run ::</span> <span class="dt">Eff</span> '[] a <span class="ot">-&gt;</span> a</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> _</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- to close the gap between our mapping and the function we want</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="ot">interpretConsoleInReaderWriter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> '[<span class="dt">Console</span>] a <span class="ot">-&gt;</span> (a, [<span class="dt">String</span>])</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>interpretConsoleInReaderWriter env <span class="ot">=</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    run <span class="op">.</span> </span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    runReader env <span class="op">.</span> </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    runWriter <span class="op">.</span> </span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    reinterpret2 consoleToReaderWriter</span></code></pre></div>
<p>OK. So now that we’ve defined our testing interpreter we’re ready to complete that property test.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- hedgehog property test</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_nameMatchesGreeting ::</span> <span class="dt">Property</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>prop_nameMatchesGreeting <span class="ot">=</span> property <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> forAll nameGenerator</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> consoleOutput <span class="ot">=</span> <span class="fu">snd</span> <span class="op">$</span> interpretConsoleInReaderWriter name (greetBot' <span class="op">$</span> <span class="fu">pure</span> ())</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> consoleOutput <span class="kw">of</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> failure <span class="co">-- nothing was emitted</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        (line<span class="op">:</span>_) <span class="ot">-&gt;</span> assert <span class="op">$</span> name <span class="ot">`isInfixOf`</span> line</span></code></pre></div>
<p>Boom! We just wrote a test that tests effects working properly within the context of our business
logic.</p>
<p>Let’s recap what just happened. With quite minimal overhead we defined a new capability <code>Console</code>
to be used throughout our application. We defined the interpreter we want it to use in the
production environment, as well as an interpreter that allows us to control inputs and measure
outputs in our test environment. Additionally, we gained the ability to write business logic
without committing to a <code>Console</code> implementation. And finally, our business logic more explicitly
states the capabilities it needs.</p>
<h2 id="can-we-do-this-to-everything">Can we do this to everything?</h2>
<p>The short answer here is yes. You absolutely can go ham on making effect algebras for everything in
your entire codebase, but every effect you introduce gives you some extra overhead. So my rule of
thumb is this: If you have some well defined semantics for your API, or you need to be able to mock
it out for testing, it’s a pretty good candidate for an Eff effect. Otherwise, you probably lose
more than you gain from this.</p>
<p>All that said, some people have taken this much further and have some really interesting results.</p>
<h1 id="time-for-the-majors">Time for the Majors</h1>
<p>OK. So the example above is pretty compelling (at least to me), but when was the last time you
actually wrote a program that only did reads and writes to the console. It was probably the first
thing you learned to do when you learned to code so it doesn’t really accurately reflect the
problems you deal with in industrial software, right?</p>
<p>Wrong. There are some reasons that you may not want to use this technique in production and I’ll
get to those at the end, but inability to express all of the things that you need is not on that
list.</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>So what we want to do is create a server that continuously fetches prices from third parties,
aggregates them some way, saves them, and then serves up the result on request.</p>
<p>It might be tempting to say that a web service that does this seems too simple to be useful,
however, if any of my colleagues were reading this, they’d tell you it looks awfully similar to a
service we have currently running in production.</p>
<h2 id="lets-write-some-new-effects">Let’s write some new effects!</h2>
<p>Ok. So immediately what jumps out at me is that since the problem statement was intentionally vague
about the third parties in question, and the method of saving, those are the candidates for…wait
for it…<em>free-monadification</em>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AssetPairing</span> <span class="ot">=</span> _</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Price</span> <span class="ot">=</span> _</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exchange</span> <span class="ot">=</span> _</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PriceFeed</span> a <span class="kw">where</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FetchPrice</span><span class="ot"> ::</span> <span class="dt">Exchange</span> <span class="ot">-&gt;</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">PriceFeed</span> <span class="dt">Price</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>makeEffect '<span class="dt">'PriceFeed</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PriceStore</span> a <span class="kw">where</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SavePrice</span><span class="ot"> ::</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Price</span> <span class="ot">-&gt;</span> <span class="dt">PriceStore</span> ()</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GetMostRecentPrice</span><span class="ot"> ::</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">PriceStore</span> <span class="dt">Price</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>makeEffect '<span class="dt">'PriceStore</span></span></code></pre></div>
<h2 id="time-to-make-the-pms-happy">Time to make the PM’s happy</h2>
<p>With just the code above we’re actually ready to write our business logic.</p>
<p>For the daemons continuously fetching and saving we have this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">allExchanges ::</span> [<span class="dt">Exchange</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>allExchanges <span class="ot">=</span> _</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">getPricesFromAllSources ::</span> <span class="dt">Member</span> <span class="dt">PriceFeed</span> effs <span class="ot">=&gt;</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> effs [<span class="dt">Price</span>]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>getPricesFromAllSources assetPairing <span class="ot">=</span> for allExchanges <span class="op">$</span> \exchange <span class="ot">-&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>   fetchPrice exchange assetPairing</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">aggregatePrices ::</span> [<span class="dt">Price</span>] <span class="ot">-&gt;</span> <span class="dt">Price</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>aggregatePrices <span class="ot">=</span> _ <span class="co">-- some fold</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="ot">fetchAndSave ::</span> (<span class="dt">Member</span> <span class="dt">PriceFeed</span> effs, <span class="dt">Member</span> <span class="dt">PriceStore</span> effs) <span class="ot">=&gt;</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> effs ()</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>fetchAndSave assetPairing <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    prices <span class="ot">&lt;-</span> getPricesFromAllSources assetPairing</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> agg <span class="ot">=</span> aggregatePrices prices</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    savePrice assetPairing agg</span></code></pre></div>
<p>And for our request handler we have this embarrassingly small piece of code here. And since we
actually want to wire this up to a real Yesod handler, let’s go ahead and do just that.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getPriceH ::</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Value</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>getPriceH assetPairing <span class="ot">=</span> <span class="op">???</span> <span class="op">$</span> <span class="fu">fmap</span> toJSON <span class="op">$</span> getMostRecentPrice assetPairing</span></code></pre></div>
<p>The astute reader might notice that we’re in the wrong monad here. We need to go from our <code>Eff</code>
defined logic to the actual handler here.</p>
<p>The above code definitely cheats. Freer monads don’t save us from having to write all the grimy
engineering details, but it <em>does</em> save us from having to interleave those details, or even commit
to them. But when we actually wire into the web application, it’s time to make a commitment. After
all we can’t avoid specifying how these prices will get fetched and saved in a real production
environment.</p>
<h2 id="make-it-work">Make it work</h2>
<p>So what will our interpreters look like?</p>
<p>Well, since we’re fetching these prices from external parties, theres pretty much no avoiding
going straight to IO, possibly with some sort of configuration for an api key.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (<span class="op">~&gt;</span>) f g <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a <span class="co">-- from freer-simple</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExchangeConf</span> <span class="ot">=</span> _</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">gdaxApiKey ::</span> <span class="dt">ExchangeConf</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">GDAXResponse</span> <span class="ot">=</span> _</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ot">gdaxRespToPrice ::</span> <span class="dt">GDAXResponse</span> <span class="ot">-&gt;</span> <span class="dt">Price</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ot">asks ::</span> <span class="dt">Member</span> (<span class="dt">Reader</span>) r effs <span class="ot">=&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> effs a</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>asks <span class="ot">=</span> _ <span class="co">-- from freer-simple</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="ot">priceFeedToRIO ::</span> (<span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ExchangeConf</span>) effs, <span class="dt">LastMember</span> <span class="dt">IO</span> effs) <span class="ot">=&gt;</span> <span class="dt">PriceFeed</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>priceFeedToRIO action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FetchPrice</span> exchange pairing <span class="ot">-&gt;</span> <span class="kw">case</span> exchange <span class="kw">of</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">GDAX</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- GDAX actually doesn't require an api key for their price api, but I'm -- making this up because enough</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- third party services require some sort of auth that this felt like it'd be more helpful</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            key <span class="ot">&lt;-</span> asks gdaxApiKey</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>            initReq <span class="ot">&lt;-</span> sendM <span class="op">.</span> parseRequest <span class="op">$</span> <span class="st">&quot;GET http://api.pro.coinbase.com/products/&quot;</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">&lt;&gt;</span> <span class="fu">show</span> pairing</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">&lt;&gt;</span> <span class="st">&quot;/ticker?apiKey=&quot;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">&lt;&gt;</span> key</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            gdaxRespToPrice <span class="op">&lt;$&gt;</span> sendM (httpJson initReq)</span></code></pre></div>
<h2 id="test-it">Test it</h2>
<p>Great. We now have a way to legitimately fetch prices from a real place. But do we want to hit GDAX
from our CI pipeline?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ExchangeTestbed</span> <span class="ot">=</span> <span class="dt">HashMap</span> (<span class="dt">Exchange</span>, <span class="dt">AssetPairing</span>) <span class="dt">Price</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">priceFeedToReader ::</span> (<span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ExchangeTestbed</span>) effs) <span class="ot">=&gt;</span> <span class="dt">PriceFeed</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>priceFeedToReader action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FetchPrice</span> exchange pairing <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        hm <span class="ot">&lt;-</span> ask</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- It's a test interpreter for a conference talk, I'm cheating totality here</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> price <span class="ot">=</span> fromJust <span class="op">$</span> <span class="fu">lookup</span> (exchange, pairing) hm</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> price</span></code></pre></div>
<p>So now we can test that our business logic saves the right data because we can control what data it
gets to begin with.</p>
<h2 id="interpreters-are-reusable">Interpreters are reusable</h2>
<p>What does the PriceStore interpreter look like? Well it depends on how we want to store the data.
Here we have some choices: an sql database (postgres), redis, live memory, or some combination of
those.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">priceStoreToPostgres ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ConnectionPool</span>) effs</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                        , <span class="dt">LastMember</span> <span class="dt">IO</span> effs</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                        ) <span class="ot">=&gt;</span> <span class="dt">PriceStore</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>priceStoreToPostgres action <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    pool <span class="ot">&lt;-</span> ask</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    Persistent.runSqlPool <span class="op">$</span> <span class="kw">case</span> action <span class="kw">of</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">SavePrice</span> pairing price <span class="ot">-&gt;</span> insert _ <span class="co">-- left as exercise</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">GetMostRecentPrice</span> pairing <span class="ot">-&gt;</span> selectFirst _ <span class="co">-- left as exercise</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">PriceCache</span> <span class="ot">=</span> <span class="dt">TVar</span> (<span class="dt">HashMap</span> <span class="dt">AssetPairing</span> <span class="dt">Price</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="ot">priceStoreToPriceCache ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">PriceCache</span>) effs</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>                          , <span class="dt">LastMember</span> <span class="dt">IO</span> effs</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>                          ) <span class="ot">=&gt;</span> <span class="dt">PriceStore</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>priceStoreToPriceCache action <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    cache <span class="ot">&lt;-</span> ask</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> action <span class="kw">of</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SavePrice</span> pairing price <span class="ot">-&gt;</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        sendM <span class="op">$</span> atomically <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>            cacheState <span class="ot">&lt;-</span> readTVar cache</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> newCacheState <span class="ot">=</span> insert pairing price cacheState</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>            writeTVar cache newCacheState</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GetMostRecentPrice</span> pairing <span class="ot">-&gt;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        sendM <span class="op">$</span> readTVarIO cache</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="ot">priceStoreToPGandCache ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ConnectionPool</span>) effs</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>                          , <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">PriceCache</span>) effs</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>                          , <span class="dt">LastMember</span> <span class="dt">IO</span> effs</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>                          ) <span class="ot">=&gt;</span> <span class="dt">PriceStore</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>priceStoreToPGandCache action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SavePrice</span> _ _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>        priceStoreToPostgres action</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>        priceStoreToPriceCache action</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GetMostRecentPrice</span> _ <span class="ot">-&gt;</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- no pg here because we're just reading, gotta go fast</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        priceStoreToPriceCache action </span></code></pre></div>
<p>Wow. So we just wrote two separate effects handlers and wrote a third one in terms of the other two.
Hopefully this conveys that something you might encounter in a real world codebase can be turned
into this style. This is still perhaps a simpler problem than the typical industry grade version,
but it’s still more than a toy and should demonstrate the type of value you would get from doing
something like this.</p>
<h1 id="why-shouldnt-i-use-this">Why shouldn’t I use this</h1>
<p>Alright alright, is it too good to be true? Just barely. The reasons why you may choose not to use
this style in a production Haskell codebase are as follows:</p>
<ul>
<li>Monadic sections of your code can be slower</li>
<li>Resource bracketing can’t be expressed this way</li>
</ul>
<p>But hope is not lost, there is an alternative library that <a href="https://reasonablypolymorphic.com/">Sandy Maguire</a>
just published called <a href="https://hackage.haskell.org/package/polysemy">polysemy</a> that pretty much
fixes both of these problems. The only reason I didn’t write this post with that as the library
being studied is because I haven’t had a chance to play with it in a production codebase yet.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Freer monads have made my code way more testable, better documented, and much better decomposed
than it used to be without. I am by no means saying this is the only way for you to accomplish
these things but it has certainly improved my code quality by quite a margin, and yet it remains
practical enough for us to deploy real-world services that use this technique to production. If
you have had a tough time testing IO code or find that you get this sense of fear when you see
a type signature of <code>a -&gt; IO b</code>, maybe give this a shot and see if it solves your problems.</p>
<p>It is also worth noting that this technique can be introduced at the edges of your existing
services without it infecting everything else, however the ergonomics of it skyrocket when you
refactor your whole codebase to use this technique. Happy coding.</p>
<p>Until next time.</p>
<p>Peace.</p>
    </section>
</article>

    </main>

    <footer>
        <div class="footer-left">
            <span>Bitcoin:
                <a href="https://www.blockchain.com/btc/address/32E3LJW2Mdc91t4e1V91pRwcMQKTALvwMG">32E3...vwMG</a></span>
        </div>
        <div class="footer-right">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </footer>
</body>

</html>
